"""
# **Disclaimer**  
# This is an **AI-assisted exploratory visualization project**.  
# Educational and experimental only. Not peer-reviewed.  
# Not mathematical research. Visual patterns are artifacts of the construction.  


INTEGER-NATIVE COMPUTATION - SYSTEM PROMPT
==========================================

NOTE: Context capture for AI systems working on this codebase.
      This is a geometric visualization project, not mathematics research.

==============================================================================
CORE PRINCIPLE
==============================================================================

Derive geometry from discrete constraints rather than discretizing continuous 
geometry. All structure emerges from integer/bitwise operations. Trigonometry 
is NEVER used in core logic, only in optional human-facing SVG rendering.

==============================================================================
THE 2-ADIC DECOMPOSITION (Foundation)
==============================================================================

FACT 1: Every positive integer n admits a UNIQUE decomposition:

    n = 2^v2(n) × core(n)

Where:
  - v2(n) ≥ 0 is the 2-adic valuation (number of trailing zeros in binary)
  - core(n) is ODD (the number with all factors of 2 removed)

FACT 2: Both components are computable using ONLY bitwise operations:

    v2(n)   = ctz(n)           # count trailing zeros
    core(n) = n >> v2(n)       # right shift

FACT 3: The SHELL of n is:

    shell(n) = floor(log2(n)) = bit_length(n) - 1

Shell k contains all integers in [2^k, 2^(k+1)), exactly 2^k integers.

==============================================================================
COORDINATE SYSTEM 1: SQUARE PERIMETER
==============================================================================

Integers are placed on concentric square perimeters.

CONSTRUCTION:
For n ≥ 2 in shell k (where 2^k ≤ n < 2^(k+1)):
  1. Square has ℓ∞ radius R = 2^k
  2. Perimeter parameter: t = (n - 2^k) / 2^k ∈ [0, 1)
  3. Coordinate: C(n) = P_R(t) where P_R parameterizes square perimeter
     clockwise from corner (-R, R)

FACT 4 (Scaling Property):
    C(2n) = 2 × C(n)    for all n ≥ 1

Doubling a number doubles its distance from origin, same direction.

THETA-KEY: Integer Angular Position
-----------------------------------
The theta_key of odd number a is computed by bit-reversal:

    theta_key(a) = bit_reverse(a, k bits)

where k is the shell of a.

THETA_KEY STRUCTURE (exp-1 bits):
┌──────────┬────────────────────────┐
│ Top 2    │ Position within edge   │
│ bits     │                        │
├──────────┼────────────────────────┤
│ 00       │ TOP edge               │
│ 01       │ RIGHT edge             │
│ 10       │ BOTTOM edge            │
│ 11       │ LEFT edge              │
└──────────┴────────────────────────┘

FACT 5: Sorting by theta_key produces the same ordering as sorting by 
geometric angle, using ONLY integer comparisons. No trigonometry.

==============================================================================
COORDINATE SYSTEM 2: RAY STRUCTURE
==============================================================================

Alternative visualization showing the same structure from a different angle.
Makes ray relationships more explicit. Can be displayed horizontal or vertical.

CONSTRUCTION ALGORITHM:
Let X = base unit distance, Y = vertical center.

STEP 1 (Origin): Place 1 at (0, Y)

STEP 2 (Shell 1):
  - Define midpoint M₁ = (X, Y)
  - Place 2 at (X, Y - X) — down from midpoint
  - Place 3 at (X, Y + X) — up from midpoint

STEP 3 (Shell k, for k ≥ 2):
  - Midpoint M_k = (X × (2 - 2^(1-k)), Y)
  - Distance from M_(k-1) to M_k is X / 2^(k-1)
  - ALL midpoints lie on horizontal line y = Y

STEP 4 (Placing Numbers):
Each odd core c defines a ray from (0, Y) with slope m_c.
For integer n with core(n) = c in shell k:

    x(n) = X × (2 - 2^(1-k))
    y(n) = Y + m_c × x(n)

FACT 6 (Defined Slopes):
┌──────┬────────┬─────────────────────────────────────┐
│ Core │ Slope  │ Property                            │
├──────┼────────┼─────────────────────────────────────┤
│ 1    │ -1     │ Descending ray                      │
│ 3    │ +1     │ Ascending ray                       │
│ 5    │  0     │ HORIZONTAL (passes all midpoints)   │
│ 7    │ +4/3   │ Steeper ascending                   │
└──────┴────────┴─────────────────────────────────────┘

For cores ≥ 9: slopes interpolated based on position among odds in 
first-appearance shell.

FACT 7 (Ray Collinearity): All integers with same odd core lie on same 
straight line through (0, Y). Follows from y = Y + m_c × x.

FACT 8 (Horizontal Ray): Core-5 ray is horizontal. 
Sequence 1, 5, 10, 20, 40, 80, ... all have y = Y.

==============================================================================
DETERMINISTIC FACTS ABOUT THE STRUCTURE
==============================================================================

SHELL PROPERTIES:

FACT 9 (Shell X-Position):
    x(shell k) = X × (2 - 2^(1-k))

Convergent geometric series approaching 2X.

┌───────┬─────────────┬──────────────────┐
│ Shell │ X-position  │ Δx from previous │
├───────┼─────────────┼──────────────────┤
│ 1     │ X           │ X                │
│ 2     │ 3X/2        │ X/2              │
│ 3     │ 7X/4        │ X/4              │
│ 4     │ 15X/8       │ X/8              │
│ k     │ X(2-2^(1-k))│ X/2^(k-1)        │
└───────┴─────────────┴──────────────────┘

FACT 10 (Y-Position Change Along Ray):
For ray with slope m, moving from shell k to k+1:

    Δy = m × Δx = m × X / 2^(k-1)

The Δy HALVES with each shell (geometric decay).

FACT 11 (Shell Composition):
Shell k contains 2^k integers:
  - 2^(k-1) are ODD (new ray positions, v2 = 0)
  - 2^(k-1) are EVEN (on existing rays, v2 ≥ 1)

FACT 12 (Coordinate Rationality):
All coordinates are RATIONAL:
    x(n) = X × (integer / 2^k)
    y(n) = Y + X × (integer / 2^k)

No irrational numbers in the construction.

NESTED SHELL STRUCTURE:

FACT 13 (Shell Inheritance):
Shell k+1 is constructed from shell k:

    Shell_(k+1) = {2n : n ∈ Shell_k} ∪ {new odd integers in [2^(k+1), 2^(k+2))}

The 2n positions are ALL on existing rays. Only new odd positions create 
new rays.

FACT 14 (Density Inheritance):
If maximum theta-key gap in shells 1 through k is G_k, then maximum gap 
in shells 1 through k+1 is AT MOST G_k.

Cumulative maximum gap can only DECREASE or STAY SAME — never increase.

Reason: New integers insert between existing positions. Insertions split 
existing gaps, never create larger ones.

FACT 15 (Lower Shell Bounds Upper):
Theta-key density characteristics of shell k provide UPPER BOUND on gap 
sizes for all higher shells:
  - If shell k has no gaps larger than G, no shell > k can have gaps > G
  - Evaluating smaller shell sufficient to establish bounds for larger shells

This is consequence of nested insertion structure.

==============================================================================
ODD-CORE RAYS
==============================================================================

FACT 16 (Bijection):
    odd_core ↔ theta_key ↔ ray

One-to-one correspondence. Different odd cores produce different rays.

FACT 17 (Ray Contents):
For odd core a, the ray contains:
    {a, 2a, 4a, 8a, 16a, ...} = {a × 2^k : k ≥ 0}

FACT 18 (Binary Pattern on Ray):
All elements share same binary prefix (bits of odd core), differing only 
in trailing zeros:

    Core 7:    7 = 111
              14 = 1110
              28 = 11100
              56 = 111000
             112 = 1110000

Each step is left-shift (×2).

NOTE ON PRIMES: Nothing unusual observed regarding primes in this structure.
Odd primes are their own odd cores (obvious from definition). This is a 
property of odd numbers, not specific to primes.

==============================================================================
TWO VIEWS OF THE SAME STRUCTURE
==============================================================================

Square-perimeter and ray-structure are the SAME object from different angles:

┌─────────────────────────┬─────────────────────────┐
│ Square-Perimeter View   │ Ray-Structure View      │
├─────────────────────────┼─────────────────────────┤
│ Shells = concentric □   │ Shells = vertical lines │
│ Theta-key along perim.  │ Theta-key vertical      │
│ Rays radiate from center│ Rays converge to pt 1   │
│ Angular position visible│ Slope relationships vis.│
└─────────────────────────┴─────────────────────────┘

Both preserve:
  - Bijection between odd cores and rays
  - Scaling property C(2n) = 2 × C(n)
  - Theta-key ordering
  - All density and gap properties

==============================================================================
INTEGER-NATIVE COMPUTATION
==============================================================================

All core operations use ONLY integers and bitwise ops:

┌────────────────┬─────────────────────────┐
│ Operation      │ Implementation          │
├────────────────┼─────────────────────────┤
│ shell(n)       │ bit_length(n) - 1       │
│ core(n)        │ n >> ctz(n)             │
│ v2(n)          │ ctz(n)                  │
│ theta_key(a)   │ bit_reverse(a)          │
└────────────────┴─────────────────────────┘

Floating-point appears ONLY in SVG pixel rendering.

VALID METRICS (for exploring neighbor relationships):

┌──────────────────┬────────────────────────────────────┬─────────────┐
│ Metric           │ Formula                            │ CUDA Cost   │
├──────────────────┼────────────────────────────────────┼─────────────┤
│ theta_key        │ odd_core_to_key(core, exp)         │ O(1) __clz  │
│ delta_theta_key  │ key2 - key1 (angular gap)          │ O(1) sub    │
│ hamming_values   │ popcount(n1 ^ n2)                  │ O(1) __popc │
│ hamming_keys     │ popcount(key1 ^ key2)              │ O(1) __popc │
│ shell, v2, popc  │ per-integer properties             │ O(1)        │
└──────────────────┴────────────────────────────────────┴─────────────┘

==============================================================================
EXTENSION TO 3D
==============================================================================

Same construction extends to three dimensions:
  - Shells become CUBE surfaces (ℓ∞ cubes)
  - Six faces instead of four edges
  - Surface area scales as 24R² instead of perimeter 8R
  - Scaling property holds: C₃(2n) = 2 × C₃(n)

2D and 3D share same algebraic properties. Nested shell structure and 
density inheritance facts apply equally to 3D.

==============================================================================
ALGORITHMIC CONSTRAINTS
==============================================================================

All core algorithms MUST obey:

1. NO TRIG/FLOATS in core logic
   - Trig ONLY in [VISUALIZATION] helpers for SVG rendering

2. THETA-KEY ORDER preserved
   - Angular walks use key stepping, not angle computation
   - Sort by theta_key for angular order

3. O(1) PER STEP operations:
   - Neighbor lookup along theta
   - Shell walks (fixed key, varying v2)
   - Ray walks (fixed core, varying shell)

4. NO REDUNDANT VERIFICATION
   - Don't check what bijection guarantees
   - Construction ensures uniqueness

5. STREAMING-FRIENDLY
   - No huge precomputed tables
   - Constant memory per operation

==============================================================================
CODE ORGANIZATION
==============================================================================

Section tags:
  [CORE]           - Integer-only operations, GPU-portable
  [NAVIGATION]     - Walking/traversal operations
  [ANALYSIS]       - Statistical analysis (valid metrics only)
  [VISUALIZATION]  - Uses floats for SVG - NOT core logic

==============================================================================
TOOLS
==============================================================================

Python:
  demo.py small-map --exp 8              # Square perimeter view
  demo.py odd-core-rays --exp 12         # Rays visualization
  demo.py ray-structure --exp 9          # Ray structure (horizontal)
  demo.py ray-structure --exp 9 --orientation vertical
  shell_walker.py --poly                 # Coordinate analysis
  shell_walker.py --svg 6-9              # Shell slice view

CUDA:
  prime_analysis.cu                      # GPU-accelerated analysis
  prime_analysis_3d.cu                   # 3D extension

==============================================================================
WHAT THIS STRUCTURE DOES NOT TELL US
==============================================================================

1. Primality is NOT determined by position
2. No shortcuts for primality testing
3. No new number-theoretic results
4. Patterns are visual artifacts of construction

This is a visualization scheme, not a proof technique.

==============================================================================
SUMMARY OF DETERMINISTIC FACTS
==============================================================================

1.  Unique 2-adic decomposition: n = 2^v2(n) × core(n)
2.  Bijection: odd_core ↔ theta_key ↔ ray
3.  Scaling: C(2n) = 2 × C(n)
4.  Shell X-position: X(2 - 2^(1-k)), converges to 2X
5.  Δx between shells: X / 2^(k-1) (halves each shell)
6.  Δy along ray: m × X / 2^(k-1) (halves each shell)
7.  Core-5 ray is horizontal (slope = 0)
8.  All coordinates are rational
9.  Shell k+1 inherits structure from shell k
10. Cumulative max theta-gap can only decrease or stay same
11. Lower shell density bounds upper shell density
12. 2D and 3D share same algebraic properties

These facts follow DIRECTLY from construction definitions.

==============================================================================
EVALUATION STYLE
==============================================================================

When assessing results:
  - NO fanfare, hype, or grandiose claims
  - State facts plainly
  - If something is tautology of construction, say so
  - "Interesting to look at" ≠ "mathematically significant"
  - Safe, non-speculative language

==============================================================================
HUMAN EXPLANATION (Optional Analogy)
==============================================================================

For explaining to humans unfamiliar with the construction:

  "Imagine a system that can only count in integers and move in four
   directions. It has no concept of angles or continuous space.
   How would it navigate and describe positions?
   
   This construction answers that question - achieving everything we do 
   with trigonometry using only bit operations."

This analogy is for PRESENTATION only. In code and technical discussion,
use "integer-native computation" terminology.
"""
